import { Entity, Column, ManyToOne, JoinColumn, OneToMany, Index } from 'typeorm';
import { z } from 'zod';
import { Model } from '@/common/models/Model';
import { Customer, CustomerApiResponse } from '../../customers/models/customer.entity';
import { Currency, CurrencyApiResponse } from '../../currencies/models/currency.entity';
import { Address, AddressApiResponse } from '../../addresses/models/address.entity';
import { User, UserApiResponse } from '@/modules/users/models/users.entity';
import {
  CreateQuoteItemInput,
  QuoteItem,
  QuoteItemApiResponse,
} from '../quote-items/models/quote-item.entity';

export enum QuoteStatus {
  DRAFT = 'draft',
  SENT = 'sent',
  ACCEPTED = 'accepted',
  REFUSED = 'refused',
  CANCELLED = 'cancelled',
  CONVERTED_TO_ORDER = 'converted_to_order',
}

const quoteSchemaValidation = z.object({
  customerId: z.number().int().positive({ message: 'Customer ID is required.' }),
  issueDate: z.coerce.date({ required_error: 'Issue date is required.' }),
  expiryDate: z.coerce.date().nullable().optional(),
  status: z.nativeEnum(QuoteStatus).optional().default(QuoteStatus.DRAFT),
  currencyId: z.number().int().positive({ message: 'Currency ID is required.' }),
  shippingAddressId: z.number().int().positive().nullable().optional(),
  billingAddressId: z.number().int().positive({ message: 'Billing Address ID is required.' }),
  notes: z.string().nullable().optional(),
  termsAndConditions: z.string().nullable().optional(),
});

export type CreateQuoteInput = {
  customerId: number;
  issueDate: string | Date;
  expiryDate?: string | Date | null;
  status?: QuoteStatus;
  currencyId: number;
  shippingAddressId?: number | null;
  billingAddressId: number;
  notes?: string | null;
  termsAndConditions?: string | null;
  items: CreateQuoteItemInput[];
};

export type UpdateQuoteInput = Partial<Omit<CreateQuoteInput, 'items' | 'customerId'>> & {
  items?: Array<Partial<CreateQuoteItemInput> & { id?: number }>;
};

export type QuoteApiResponse = {
  id: number;
  quoteNumber: string;
  customerId: number;
  customer?: CustomerApiResponse | null;
  issueDate: string | null;
  expiryDate: string | null;
  status: QuoteStatus;
  currencyId: number;
  currency?: CurrencyApiResponse | null;
  shippingAddressId: number | null;
  shippingAddress?: AddressApiResponse | null;
  billingAddressId: number;
  billingAddress?: AddressApiResponse | null;
  totalAmountHt: number;
  totalVatAmount: number;
  totalAmountTtc: number;
  notes: string | null;
  termsAndConditions: string | null;
  items?: QuoteItemApiResponse[];
  createdByUserId: number | null;
  createdByUser?: UserApiResponse | null;
  updatedByUserId: number | null;
  // updatedByUser?: EmbeddedUserApiResponse | null;
  createdAt: string | null;
  updatedAt: string | null;
};

export const quoteValidationInputErrors: string[] = [];

@Entity({ name: 'quotes' })
@Index(['customerId', 'status'])
@Index(['issueDate'])
export class Quote extends Model {
  @Column({ type: 'varchar', length: 50, name: 'quote_number', unique: true })
  quoteNumber!: string; // Auto-generated by service

  @Column({ type: 'int', name: 'customer_id' })
  customerId!: number;

  @ManyToOne(() => Customer, { eager: true, onDelete: 'RESTRICT' })
  @JoinColumn({ name: 'customer_id' })
  customer!: Customer;

  @Column({ type: 'date', name: 'issue_date' })
  issueDate!: Date;

  @Column({ type: 'date', name: 'expiry_date', nullable: true })
  expiryDate: Date | null = null;

  @Column({
    type: 'varchar', // Ou 'enum'
    length: 30,
    enum: QuoteStatus,
    default: QuoteStatus.DRAFT,
  })
  status!: QuoteStatus;

  @Column({ type: 'int', name: 'currency_id' })
  currencyId!: number;

  @ManyToOne(() => Currency, { eager: true, onDelete: 'RESTRICT' })
  @JoinColumn({ name: 'currency_id' })
  currency!: Currency;

  @Column({ type: 'int', name: 'shipping_address_id', nullable: true })
  shippingAddressId: number | null = null;

  @ManyToOne(() => Address, { eager: true, onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'shipping_address_id' })
  shippingAddress: Address | null = null;

  @Column({ type: 'int', name: 'billing_address_id' })
  billingAddressId!: number;

  @ManyToOne(() => Address, { eager: true, onDelete: 'RESTRICT' })
  @JoinColumn({ name: 'billing_address_id' })
  billingAddress!: Address;

  @Column({ type: 'decimal', precision: 15, scale: 4, name: 'total_amount_ht', default: 0.0 })
  totalAmountHt: number = 0;

  @Column({ type: 'decimal', precision: 15, scale: 4, name: 'total_vat_amount', default: 0.0 })
  totalVatAmount: number = 0;

  @Column({ type: 'decimal', precision: 15, scale: 4, name: 'total_amount_ttc', default: 0.0 })
  totalAmountTtc: number = 0;

  @Column({ type: 'text', nullable: true })
  notes: string | null = null;

  @Column({ type: 'text', nullable: true, name: 'terms_and_conditions' })
  termsAndConditions: string | null = null;

  @OneToMany(() => QuoteItem, (item) => item.quote, {
    cascade: ['insert', 'update', 'remove'],
    eager: true,
  }) // Cascade operations to items
  items!: QuoteItem[];

  @Column({ type: 'int', name: 'created_by_user_id' })
  createdByUserId!: number;

  @ManyToOne(() => User, { eager: true, onDelete: 'RESTRICT' })
  @JoinColumn({ name: 'created_by_user_id' })
  createdByUser!: User;

  @Column({ type: 'int', name: 'updated_by_user_id', nullable: true })
  updatedByUserId: number | null = null;

  @ManyToOne(() => User, { eager: true, onDelete: 'SET NULL', nullable: true })
  @JoinColumn({ name: 'updated_by_user_id' })
  updatedByUser: User | null = null;

  calculateTotals(): void {
    this.totalAmountHt = 0;
    this.totalVatAmount = 0;
    if (this.items && this.items.length > 0) {
      this.items.forEach((item) => {
        const lineTotalHt = item.getCalculatedTotalLineAmountHt();
        this.totalAmountHt += lineTotalHt;
        if (item.vatRatePercentage !== null) {
          this.totalVatAmount += lineTotalHt * (item.vatRatePercentage / 100);
        }
      });
    }
    this.totalAmountHt = parseFloat(this.totalAmountHt.toFixed(4));
    this.totalVatAmount = parseFloat(this.totalVatAmount.toFixed(4));
    this.totalAmountTtc = parseFloat((this.totalAmountHt + this.totalVatAmount).toFixed(4));
  }

  toApi(): QuoteApiResponse {
    const base = super.toApi();
    return {
      ...base,
      id: this.id,
      quoteNumber: this.quoteNumber,
      customerId: this.customerId,
      customer: this.customer
        ? ({
            id: this.customer.id,
            displayName: this.customer.getDisplayName(),
            email: this.customer.email,
          } as CustomerApiResponse)
        : null,
      issueDate: Model.formatISODate(this.issueDate),
      expiryDate: Model.formatISODate(this.expiryDate),
      status: this.status,
      currencyId: this.currencyId,
      currency: this.currency ? this.currency.toApi() : null,
      shippingAddressId: this.shippingAddressId,
      shippingAddress: this.shippingAddress ? this.shippingAddress?.toApi() : null,
      billingAddressId: this.billingAddressId,
      billingAddress: this.billingAddress ? this.billingAddress?.toApi() : null,
      totalAmountHt: Number(this.totalAmountHt),
      totalVatAmount: Number(this.totalVatAmount),
      totalAmountTtc: Number(this.totalAmountTtc),
      notes: this.notes,
      termsAndConditions: this.termsAndConditions,
      items: this.items?.map((item) => item.toApi()),
      createdByUserId: this.createdByUserId,
      createdByUser: this.createdByUser ? this.createdByUser?.toApi() : null,
      updatedByUserId: this.updatedByUserId,
      createdAt: Model.formatISODate(this.createdAt),
      updatedAt: Model.formatISODate(this.updatedAt),
    };
  }

  isValid(): boolean {
    const dataToValidate = {
      customerId: this.customerId,
      issueDate: this.issueDate,
      expiryDate: this.expiryDate,
      status: this.status,
      currencyId: this.currencyId,
      shippingAddressId: this.shippingAddressId,
      billingAddressId: this.billingAddressId,
      notes: this.notes,
      termsAndConditions: this.termsAndConditions,
    };
    const result = quoteSchemaValidation.safeParse(dataToValidate);
    quoteValidationInputErrors.length = 0;
    if (!result.success) {
      quoteValidationInputErrors.push(
        ...result.error.issues.map(
          (issue) => `${issue.path.join('.') || 'Field'}: ${issue.message}`,
        ),
      );
      return false;
    }
    // Validate items individually
    if (this.items) {
      for (const item of this.items) {
        if (!item.isValid()) {
          // Assuming QuoteItem has isValid
          // Errors from item.isValid() are already pushed to its own error array
          // Could aggregate them here if needed.
          quoteValidationInputErrors.push(`Invalid item data for product ID ${item.productId}.`);
          return false;
        }
      }
    } else if (this.status !== QuoteStatus.DRAFT) {
      // Non-draft quotes should ideally have items
      quoteValidationInputErrors.push('Items: A non-draft quote should have items.');
      // return false; // This might be too strict, depends on business logic
    }

    return true;
  }
}
